name: Daily Job Search (20:00 IST)

on:
  schedule:
    # 20:00 IST == 14:30 UTC
    - cron: "30 14 * * *"
  workflow_dispatch:

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout empty repo
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: python -m pip install --upgrade pip requests pandas

      - name: Create job_finder.py
        run: |
          cat > job_finder.py << 'PY'
#!/usr/bin/env python3
"""
Job Search & Email Automation
- Queries SerpAPI Google Jobs for target roles across regions (US, Europe, Australia, New Zealand)
- Filters postings that mention visa sponsorship or relocation support
- Outputs a concise table and emails it
Schedule: daily at 20:00 IST via GitHub Actions (or any scheduler)
"""
import os
import sys
import time
import json
import smtplib
import ssl
import logging
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from typing import List, Dict, Any
from datetime import datetime, timezone, timedelta

try:
    import requests
    import pandas as pd
except ModuleNotFoundError:
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "requests", "pandas"])
    import requests
    import pandas as pd

# ------------------ Config ------------------
SEARCH_TERMS = [
    "Agile Program Manager",
    "Program Manager",
    "Scrum Master",
    "Project Manager"
]

# Regions & locations for Google Jobs (SerpAPI). You can add cities for better coverage.
REGIONS = [
    {"label": "United States", "location": "United States"},
    {"label": "Europe", "location": "Europe"},
    {"label": "Australia", "location": "Australia"},
    {"label": "New Zealand", "location": "New Zealand"}
]

# Keywords that imply visa sponsorship or relocation
KEYWORDS_ANY = [
    "visa", "sponsorship", "sponsor", "work permit", "work authorization",
    "work authorisation", "relocation", "relocation support", "relocation assistance",
    "relocation package", "relocation bonus", "visa support"
]

# Email table columns
COLUMNS = ["Company Name", "Job Title", "Location", "Visa/Relocation Sponsorship (Yes/No)", "Application Link"]

SERPAPI_KEY = os.getenv("SERPAPI_KEY", "").strip()
SENDER_EMAIL = os.getenv("SENDER_EMAIL", "").strip()
SENDER_NAME  = os.getenv("SENDER_NAME", "JobBot").strip()
SMTP_SERVER  = os.getenv("SMTP_SERVER", "smtp.gmail.com").strip()
SMTP_PORT    = int(os.getenv("SMTP_PORT", "465"))
SMTP_USERNAME= os.getenv("SMTP_USERNAME", SENDER_EMAIL).strip()
SMTP_PASSWORD= os.getenv("SMTP_PASSWORD", "").strip()
RECIPIENTS   = [e.strip() for e in os.getenv("RECIPIENT_EMAILS", "").split(",") if e.strip()]
MAX_RESULTS_PER_QUERY = int(os.getenv("MAX_RESULTS_PER_QUERY", "20"))
DAYS_BACK_LIMIT = int(os.getenv("DAYS_BACK_LIMIT", "14"))  # ignore jobs older than this many days if 'detected_extensions' has posted_at
STRICT_MATCH = os.getenv("STRICT_MATCH", "false").lower() == "true"  # if true, require keywords in title or description

# Logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s - %(message)s")
logger = logging.getLogger("jobfinder")

def serpapi_jobs_search(query: str, location: str, api_key: str, start: int = 0) -> Dict[str, Any]:
    url = "https://serpapi.com/search.json"
    params = {
        "engine": "google_jobs",
        "q": query,
        "location": location,
        "hl": "en",
        "start": start,
        "api_key": api_key
    }
    r = requests.get(url, params=params, timeout=30)
    r.raise_for_status()
    return r.json()

def serpapi_job_detail(job_id: str, api_key: str) -> Dict[str, Any]:
    url = "https://serpapi.com/search.json"
    params = {
        "engine": "google_jobs_listing",
        "q": job_id,
        "hl": "en",
        "api_key": api_key
    }
    r = requests.get(url, params=params, timeout=30)
    r.raise_for_status()
    return r.json()

def posted_within_limit(job: Dict[str, Any], days: int) -> bool:
    ext = job.get("detected_extensions", {}) or {}
    posted_at = ext.get("posted_at") or ext.get("posted_at_raw")
    if not posted_at:
        return True  # keep if unknown
    # Lightweight parse: handle patterns like "1 day ago", "3 days ago", "30+ days ago"
    try:
        txt = str(posted_at).lower()
        if "day" in txt:
            num = "".join(ch for ch in txt if ch.isdigit())
            if num:
                return int(num) <= days
            if "30+" in txt:
                return 30 <= days
        # if it's a date-like string, keep it
        return True
    except Exception:
        return True

def contains_keywords(text: str) -> bool:
    t = (text or "").lower()
    return any(kw in t for kw in KEYWORDS_ANY)

def extract_apply_link(job: Dict[str, Any]) -> str:
    # Prefer direct apply option
    for opt in job.get("apply_options", []) or []:
        if opt.get("link"):
            return opt["link"]
    # Fallback to job's google_jobs_url or 'share_link'
    return job.get("share_link") or job.get("google_jobs_url") or ""

def normalize_job(job: Dict[str, Any], detail: Dict[str, Any]) -> Dict[str, Any]:
    title = job.get("title", "").strip()
    company = job.get("company_name", "").strip()
    location = job.get("location", "").strip()
    desc = (detail.get("job_description") or job.get("description") or "").strip()
    link = extract_apply_link(job)
    has_support = contains_keywords(title) or contains_keywords(desc)
    return {
        "Company Name": company,
        "Job Title": title,
        "Location": location,
        "Visa/Relocation Sponsorship (Yes/No)": "Yes" if has_support else "No",
        "Application Link": link,
        "_job_id": job.get("job_id", ""),
        "_title": title.lower(),
        "_company": company.lower(),
        "_raw_desc": desc
    }

def search_all() -> pd.DataFrame:
    if not SERPAPI_KEY:
        raise RuntimeError("Missing SERPAPI_KEY environment variable.")
    all_rows: List[Dict[str, Any]] = []
    for region in REGIONS:
        loc = region["location"]
        for term in SEARCH_TERMS:
            logger.info(f"Querying: {term} @ {loc}")
            # fetch first batch
            start = 0
            fetched = 0
            while fetched < MAX_RESULTS_PER_QUERY:
                try:
                    data = serpapi_jobs_search(term, loc, SERPAPI_KEY, start=start)
                except Exception as e:
                    logger.warning(f"Search error at start={start}: {e}")
                    break
                jobs = data.get("jobs_results", []) or []
                if not jobs:
                    break
                for job in jobs:
                    if not posted_within_limit(job, DAYS_BACK_LIMIT):
                        continue
                    job_id = job.get("job_id")
                    detail = {}
                    if job_id:
                        try:
                            detail = serpapi_job_detail(job_id, SERPAPI_KEY)
                            time.sleep(0.5)  # be gentle
                        except Exception as e:
                            logger.warning(f"Detail fetch failed for {job_id}: {e}")
                    row = normalize_job(job, detail)
                    if STRICT_MATCH and row["Visa/Relocation Sponsorship (Yes/No)"] != "Yes":
                        continue
                    all_rows.append(row)
                fetched += len(jobs)
                start += len(jobs)
                time.sleep(0.8)  # throttle between pages
    if not all_rows:
        return pd.DataFrame(columns=COLUMNS)
    df = pd.DataFrame(all_rows)
    # Deduplicate by job_id or title+company
    if "_job_id" in df.columns:
        df = df.sort_values(by=["_job_id"]).drop_duplicates(subset=["_job_id"], keep="first")
    df = df.drop_duplicates(subset=["_title", "_company"], keep="first")
    df = df[COLUMNS]
    # Keep only rows marked Yes for final output
    df = df[df["Visa/Relocation Sponsorship (Yes/No)"] == "Yes"].reset_index(drop=True)
    return df

def df_to_html_table(df: pd.DataFrame) -> str:
    if df.empty:
        return "<p>No matching roles found today with visa/relocation support.</p>"
    # Simple clean table
    html = ['<table border="1" cellpadding="6" cellspacing="0" style="border-collapse:collapse;font-family:Arial, sans-serif;font-size:13px;">']
    # Header
    html.append("<tr>" + "".join(f"<th align='left'>{col}</th>" for col in df.columns) + "</tr>")
    # Rows
    for _, row in df.iterrows():
        html.append("<tr>" + "".join(f"<td>{row[col]}</td>" for col in df.columns) + "</tr>")
    html.append("</table>")
    return "\\n".join(html)

def send_email(subject: str, html_body: str):
    if not (SENDER_EMAIL and SMTP_PASSWORD and RECIPIENTS):
        raise RuntimeError("Missing email configuration (SENDER_EMAIL / SMTP_PASSWORD / RECIPIENT_EMAILS).")
    msg = MIMEMultipart("alternative")
    msg["Subject"] = subject
    msg["From"] = f"{SENDER_NAME} <{SENDER_EMAIL}>"
    msg["To"] = ", ".join(RECIPIENTS)
    part = MIMEText(html_body, "html")
    msg.attach(part)
    context = ssl.create_default_context()
    with smtplib.SMTP_SSL(SMTP_SERVER, SMTP_PORT, context=context) as server:
        server.login(SMTP_USERNAME, SMTP_PASSWORD)
        server.sendmail(SENDER_EMAIL, RECIPIENTS, msg.as_string())

def main():
    logger.info("Starting job search...")
    df = search_all()
    today_ist = datetime.utcnow().replace(tzinfo=timezone.utc) + timedelta(hours=5, minutes=30)
    date_str = today_ist.strftime("%Y-%m-%d")
    subject = f"Daily Roles with Visa/Relocation Support â€” {date_str}"
    html_body = f"""
    <p>Below are today's matches (visa sponsorship or relocation support mentioned):</p>
    {df_to_html_table(df)}
    <p>Search terms: {', '.join(SEARCH_TERMS)}</p>
    <p>Regions: {', '.join([r['label'] for r in REGIONS])}</p>
    <p><em>Automated by job_finder.py</em></p>
    """
    # Save CSV snapshot
    out_csv = f"results_{date_str}.csv"
    df.to_csv(out_csv, index=False)
    logger.info(f"Saved: {out_csv}")
    # Email
    send_email(subject, html_body)
    logger.info("Email sent.")
    return 0

if __name__ == "__main__":
    sys.exit(main())

PY
      - name: Run
        env:
          SERPAPI_KEY: ${ secrets.SERPAPI_KEY }
          SENDER_EMAIL: ${ secrets.SENDER_EMAIL }
          SENDER_NAME: ${ secrets.SENDER_NAME }
          SMTP_SERVER: ${ secrets.SMTP_SERVER }
          SMTP_PORT: ${ secrets.SMTP_PORT }
          SMTP_USERNAME: ${ secrets.SMTP_USERNAME }
          SMTP_PASSWORD: ${ secrets.SMTP_PASSWORD }
          RECIPIENT_EMAILS: ${ secrets.RECIPIENT_EMAILS }
          MAX_RESULTS_PER_QUERY: ${ vars.MAX_RESULTS_PER_QUERY }
          DAYS_BACK_LIMIT: ${ vars.DAYS_BACK_LIMIT }
          STRICT_MATCH: ${ vars.STRICT_MATCH }
        run: python job_finder.py
